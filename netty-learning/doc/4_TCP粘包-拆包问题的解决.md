### TCP粘包/拆包

TCP是一个“流”协议，所谓流，就是没有界限的一串数据。

TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，

所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

---
### TCP粘包/拆包问题说明

假设客户端分别发送了两个数据包D1 和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下情况：

* 服务端分两次读取到了两个独立的数据包，分别是D1 和 D2，没有粘包和拆包
* 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包
* 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称为TCP拆包
* 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。
* 如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很可能会发生第5种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包

---
### TCP粘包/拆包发生的原因

问题产生的原因有三个，分别如下：

* 应用程序write写入的字节大小大于套接口发送缓冲区大小；
* 进行MSS大小的TCP分段；
* 以太网帧的payload大于MTU进行IP分片。

---
### 粘包问题的解决策略
由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

* 消息定长，例如每个报文的大小固定长度为200字节，如果不够，空位补空格；
* 在包尾添加回车换行符进行分割，例如FTP协议；
* 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
* 更复杂的应用协议。

---
### Netty解决粘包/拆包问题

使用`LineBaseFrameDecoder + StringDecoder`的方式，很容易就可以解决：

①服务器和客户端都添加这两个分隔符解码器
 ```
 ch.pipeline().addLast(new LineBasedFrameDecoder(1024));
 ch.pipeline().addLast(new StringDecoder());
 ```
②服务器和客户端发送的消息，都以分隔符结尾。
 <br>即`消息 = 初始消息+System.getProperty("line.separator")`



 `LineBaseFrameDecoder`的工作原理：它一次遍历ByteBuf中的可读字节，判断看是否有`\n`或者` \r\n`，
 如果有，就以此为结束位置，从可读索引到结束位置区间的字节就组成了一行。

 它是以换行符为结束标志的解码器，支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。
 如果连续读取到最长长度后仍然没有发现换行符，就会抛出异常，同时忽略之前读到的异常码流。

 `StringDecoder`的功能很简单，就是将接受到的对象转换为字符串，然后继续调用后面的handler。


 `LineBaseFrameDecoder + StringDecoder`组合就是按行切换的文本解码器，
 它被设计用来支持TCP的粘包和拆包。

 当然，如果消息不是以换行符结束，Netty提供了多种其他支持TCP粘包\拆包的解码器，用来满足用户需求。


 ---
 代码对应以下目录：

`time_server_netty_having_sticky_package_problem`

`time_server_netty_solving_sticky_package_problem`